# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: external.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class KnownTokenId(betterproto.Enum):
    """
    / A list of "known" token id's and their names.// Note that this is not an
    exhaustive list and clients should gracefully handle/ the scenario that
    they receive a tx out with a token id they don't know about yet.// If
    changing this, please keep it in sync with the list defined in/ mc-
    transaction-core in the tokens module.
    """

    MOB = 0


@dataclass
class RistrettoPrivate(betterproto.Message):
    """/ A Ristretto private key."""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class CompressedRistretto(betterproto.Message):
    """/ A 32-byte compressed Ristretto curve point (public key)"""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class Ed25519Public(betterproto.Message):
    """/ An Ed25519 public key, for validating signatures."""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class Ed25519Signature(betterproto.Message):
    """/ An Ed25519 signature object"""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class Ed25519MultiSig(betterproto.Message):
    signatures: List["Ed25519Signature"] = betterproto.message_field(1)


@dataclass
class Ed25519SignerSet(betterproto.Message):
    individual_signers: List["Ed25519Public"] = betterproto.message_field(1)
    multi_signers: List["Ed25519SignerSet"] = betterproto.message_field(3)
    threshold: int = betterproto.uint32_field(2)


@dataclass
class AccountKey(betterproto.Message):
    """
    / Complete AccountKey, containing the pair of secret keys, which can be
    used/ for spending, and optionally some Fog related info that is used to
    form/ public addresses for accounts that sign up with Fog service.// This
    matches the Rust `transaction::AccountKey` struct.
    """

    # / Private key 'a' used for view-key matching.
    view_private_key: "RistrettoPrivate" = betterproto.message_field(1)
    # / Private key `b` used for spending.
    spend_private_key: "RistrettoPrivate" = betterproto.message_field(2)
    # / Optional url of fog report server./ Empty string when not in use, i.e.
    # for accounts that don't have fog service.
    fog_report_url: str = betterproto.string_field(3)
    # / Optional fog report id./ The fog report server may serve multiple
    # reports, this id disambiguates/ which one to use when sending to this
    # account.
    fog_report_id: str = betterproto.string_field(4)
    # / Optional fog authority subjectPublicKeyInfo./ Empty when not in use.
    fog_authority_spki: bytes = betterproto.bytes_field(5)


@dataclass
class PublicAddress(betterproto.Message):
    """/ A public address, used to identify recipients."""

    # / View public key
    view_public_key: "CompressedRistretto" = betterproto.message_field(1)
    # / Spend public key
    spend_public_key: "CompressedRistretto" = betterproto.message_field(2)
    # / Optional url of fog report server./ Empty string when not in use, i.e.
    # for accounts that don't have fog service./ Indicates the place at which the
    # fog report server should be contacted.
    fog_report_url: str = betterproto.string_field(3)
    # / Optional fog report id./ The fog report server may serve multiple
    # reports, this id disambiguates/ which one to use when sending to this
    # account.
    fog_report_id: str = betterproto.string_field(4)
    # / View key signature over the fog authority subjectPublicKeyInfo.// This
    # must be parseable as a RistrettoSignature.
    fog_authority_sig: bytes = betterproto.bytes_field(5)


@dataclass
class RootIdentity(betterproto.Message):
    """
    / A KDF can be used to stretch a 32 byte secret into multiple secret
    private keys./ The RootIdentity is a compact form of a user's account key,
    if it has been/ derived in this way. This may be useful for e.g. paper
    wallets.
    """

    # / The root entropy used to derive cryptonote private keys for this account
    root_entropy: "RootEntropy" = betterproto.message_field(1)
    # / Optional url of fog report server, same as in AccountKey
    fog_report_url: str = betterproto.string_field(2)
    # / Optional fog report id, same as in AccountKey
    fog_report_id: str = betterproto.string_field(3)
    # / Optional fog authority subjectPublicKeyInfo./ Empty when not in use.
    fog_authority_spki: bytes = betterproto.bytes_field(5)


@dataclass
class RootEntropy(betterproto.Message):
    """/ A 32 byte secret used as input key material to derive private keys"""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class CurveScalar(betterproto.Message):
    """
    / A 32-byte scalar associated to the ristretto group./ This is the same as
    RistrettoPrivate, but they are used in different places./ TODO: MC-1605
    Consider to factor out this type, or just this proto message.
    """

    data: bytes = betterproto.bytes_field(1)


@dataclass
class KeyImage(betterproto.Message):
    """/ A 32-byte mobilecoin transaction key image."""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class Range(betterproto.Message):
    from_: int = betterproto.uint64_field(1)
    to: int = betterproto.uint64_field(2)


@dataclass
class TxOutMembershipHash(betterproto.Message):
    data: bytes = betterproto.bytes_field(1)


@dataclass
class TxOutMembershipElement(betterproto.Message):
    range: "Range" = betterproto.message_field(1)
    hash: "TxOutMembershipHash" = betterproto.message_field(2)


@dataclass
class TxOutMembershipProof(betterproto.Message):
    index: int = betterproto.uint64_field(1)
    highest_index: int = betterproto.uint64_field(2)
    elements: List["TxOutMembershipElement"] = betterproto.message_field(3)


@dataclass
class TxOutConfirmationNumber(betterproto.Message):
    """
    A hash of the shared secret of a transaction output. Can be used by the
    recipient of a transaction output to verify that the bearer of this number
    knew the shared secret of the transaction output, thereby providing
    evidence that they are the sender.
    """

    hash: bytes = betterproto.bytes_field(1)


@dataclass
class MaskedAmount(betterproto.Message):
    """MaskedAmount."""

    # A Pedersen commitment `v*G + s*H`
    commitment: "CompressedRistretto" = betterproto.message_field(1)
    # `masked_value = value XOR_8 Blake2B("value_mask" || shared_secret)`
    masked_value: float = betterproto.fixed64_field(2)
    # `masked_token_id = token_id XOR_8 Blake2B("token_id_mask" ||
    # shared_secret)`
    masked_token_id: bytes = betterproto.bytes_field(3)


@dataclass
class EncryptedFogHint(betterproto.Message):
    """The bytes of encrypted fog hint"""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class EncryptedMemo(betterproto.Message):
    """The bytes of encrypted memo"""

    data: bytes = betterproto.bytes_field(1)


@dataclass
class TxOut(betterproto.Message):
    """A Transaction Output."""

    masked_amount_v1: "MaskedAmount" = betterproto.message_field(
        1, group="masked_amount"
    )
    masked_amount_v2: "MaskedAmount" = betterproto.message_field(
        6, group="masked_amount"
    )
    # Public key.
    target_key: "CompressedRistretto" = betterproto.message_field(2)
    # Public key.
    public_key: "CompressedRistretto" = betterproto.message_field(3)
    # Encrypted fog hint payload. This is an mc-crypto-box cryptogram for the fog
    # ingest server, or a random cryptogram indistinguishable from a real one.
    e_fog_hint: "EncryptedFogHint" = betterproto.message_field(4)
    # Encrypted memo
    e_memo: "EncryptedMemo" = betterproto.message_field(5)


@dataclass
class TxIn(betterproto.Message):
    # "Ring" of inputs, one of which is actually being spent.
    ring: List["TxOut"] = betterproto.message_field(1)
    # Proof that each TxOut in `ring` is in the ledger.
    proofs: List["TxOutMembershipProof"] = betterproto.message_field(2)
    # Any rules specified by the signed input
    input_rules: "InputRules" = betterproto.message_field(3)


@dataclass
class InputRules(betterproto.Message):
    """
    Rules enforced on a transaction by a signed input within it (MCIP #31)
    """

    # Outputs required to appear in the TxPrefix for the Tx to be valid
    required_outputs: List["TxOut"] = betterproto.message_field(1)
    # A maximum value which the tombstone block for the Tx cannot exceed A value
    # of zero here means no limit is enforced
    max_tombstone_block: float = betterproto.fixed64_field(2)
    # Outputs required to appear in the TxPrefix, but which are permitted to be
    # filled partially instead of fully, according to the "fill fraction" which
    # is inferred using the "partial fill change" output (MCIP #42)
    partial_fill_outputs: List["RevealedTxOut"] = betterproto.message_field(3)
    # A change output for any leftover from this input, which may occur during a
    # partial fill (MCIP #42). This field must be present whenever partial fills
    # are used, because the comparison of this "idealized" output and the
    # corresponding "fractional" change which appears in the TxPrefix is what
    # determines the "fill fraction", that is, the degree to which a counterparty
    # is obliged to fill every partial fill output in these rules. It is an error
    # to use any of the partial fill options without also setting this.
    partial_fill_change: "RevealedTxOut" = betterproto.message_field(4)
    # A minimum fill value for the partial fill rules. (MCIP #42) A counterparty
    # who fills an SCI must keep at least this much of the offer and can't return
    # all of it as change if this is set. This can be used to prevent griefing
    # where someone fills your offer in exchange for dust. This minimum has no
    # effect if set to 0.
    min_partial_fill_value: float = betterproto.fixed64_field(5)


@dataclass
class RevealedTxOut(betterproto.Message):
    """
    A TxOut together with its amount shared secret. This is sometimes needed to
    properly validate partial fill transactions (MCIP #42).
    """

    # The TxOut
    tx_out: "TxOut" = betterproto.message_field(1)
    # Amount shared secret. This can be used to see the masked value and token id
    # and confirm that they match the amount commitment. This must be exactly 32
    # bytes, and should be derived from TxOut shared secret using domain-
    # separated SHA512 as in transaction-core.
    amount_shared_secret: bytes = betterproto.bytes_field(2)


@dataclass
class TxPrefix(betterproto.Message):
    """A transaction that a client submits to consensus"""

    # Transaction inputs.
    inputs: List["TxIn"] = betterproto.message_field(1)
    # Transaction outputs.
    outputs: List["TxOut"] = betterproto.message_field(2)
    # Fee paid to the foundation for this transaction
    fee: int = betterproto.uint64_field(3)
    # The block index at which this transaction is no longer valid.
    tombstone_block: int = betterproto.uint64_field(4)
    # Token id for the fee of this transaction
    fee_token_id: float = betterproto.fixed64_field(5)


@dataclass
class RingMLSAG(betterproto.Message):
    """
    A ring mlsag is a group-ring signature conferring spending authority of one
    TxOut which is part of a TxIn.
    """

    # The initial challenge value for the ring signature
    c_zero: "CurveScalar" = betterproto.message_field(1)
    # The "responses", one for each input which is signed
    responses: List["CurveScalar"] = betterproto.message_field(2)
    # The key image is a hash unique to the "true" spent input. This cannot be
    # linked back to determine the true spent input, but the input cannot be
    # spent again without producing the same key image value, so this is used to
    # prevent double-spends.
    key_image: "KeyImage" = betterproto.message_field(3)


@dataclass
class SignatureRctBulletproofs(betterproto.Message):
    # A ring-signature, one for each TxIn, producing one pseudo-output and key
    # image.
    ring_signatures: List["RingMLSAG"] = betterproto.message_field(1)
    # The amount commitments for each pseudo-output. There must be one of these
    # for each TxIn.
    pseudo_output_commitments: List["CompressedRistretto"] = betterproto.message_field(
        2
    )
    # Before mixed transactions feature, there is one range proof for all pseudo-
    # output and output commitments, whose serialized bytes appear here. After
    # mixed transactions feature, this field is empty.
    range_proof_bytes: bytes = betterproto.bytes_field(3)
    # Before mixed transactions feature, this field is empty. After mixed
    # transactions feature, this field contains one range proof for each token id
    # which appears in the transaction, in sorted order of token ids. It range-
    # proofs the pseudo-outputs and outputs with that token id, in the order that
    # they appear in the transaction.
    range_proofs: List[bytes] = betterproto.bytes_field(4)
    # The token ids of each pseudo ouptut. There must be one of these for each
    # TxIn. Before mixed transactions feature, this field is empty, and the token
    # ids of all pseudo-outputs are inferred from the tx.prefix.fee_token_id.
    pseudo_output_token_ids: List[float] = betterproto.fixed64_field(5)
    # The token ids of each output. There must be one of these for each output of
    # the Tx. (tx.prefix.outputs). Before mixed transactions feature, this field
    # is empty, and the token ids of all outputs are inferred from the
    # tx.prefix.fee_token_id.
    output_token_ids: List[float] = betterproto.fixed64_field(6)


@dataclass
class Tx(betterproto.Message):
    # The actual contents of the transaction.
    prefix: "TxPrefix" = betterproto.message_field(1)
    # The RingCT signature on the prefix.
    signature: "SignatureRctBulletproofs" = betterproto.message_field(2)
    # Client's belief about the minimum fee map, expressed as a merlin digest.
    # The enclave must reject the proposal if this doesn't match the enclave's
    # belief, to protect the client from information disclosure attacks. (This is
    # TOB-MCCT-5)
    fee_map_digest: bytes = betterproto.bytes_field(3)


@dataclass
class TxHash(betterproto.Message):
    # Hash of a single transaction.
    hash: bytes = betterproto.bytes_field(1)


@dataclass
class Receipt(betterproto.Message):
    """
    Given to the recipient of a transaction output by the sender so that the
    recipient may verify that the other party is indeed the sender. Often given
    to the recipient before the transaction is finalized so that the recipient
    may know to anticipate the arrival of a transaction output, as well as know
    who it's from, when to consider it as having surpassed the tombstone block,
    and the expected amount of the output.
    """

    # Public key of the TxOut.
    public_key: "CompressedRistretto" = betterproto.message_field(1)
    # Confirmation number of the TxOut.
    confirmation: "TxOutConfirmationNumber" = betterproto.message_field(2)
    # Tombstone block of the Tx that produced the TxOut. Note: This value is
    # self-reported by the sender and is unverifiable.
    tombstone_block: int = betterproto.uint64_field(3)
    masked_amount_v1: "MaskedAmount" = betterproto.message_field(
        4, group="masked_amount"
    )
    masked_amount_v2: "MaskedAmount" = betterproto.message_field(
        5, group="masked_amount"
    )


@dataclass
class VerificationSignature(betterproto.Message):
    """/ The signature over an IAS JSON reponse, created by Intel"""

    contents: bytes = betterproto.bytes_field(1)


@dataclass
class VerificationReport(betterproto.Message):
    """/ The IAS verification report response encoded as a protocol buffer"""

    # / The IAS-generated signature over the response string
    sig: "VerificationSignature" = betterproto.message_field(1)
    # / A list of byte strings representing the DER-encoded certificate/ chain
    # provided by IAS.
    chain: List[bytes] = betterproto.bytes_field(2)
    # / The raw report body JSON, as a byte sequence
    http_body: str = betterproto.string_field(3)


@dataclass
class Quote3(betterproto.Message):
    """
    / SGX quote version 3 as specified in/ <https://download.01.org/intel-
    sgx/latest/dcap-latest/linux/docs/Intel_SGX_ECDSA_QuoteLibReference_DCAP_AP
    I.pdf#%5B%7B%22num%22%3A73%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7
    D%2C52%2C375%2C0%5D>. This is type is used in block chain types and should
    not have fields removed. New fields can be added, but will be assumed
    optional by consumers
    """

    # / The raw bytestream of the quote. This will contain only the/ bytes
    # specified in <https://download.01.org/intel-sgx/latest/dcap-latest/linux/do
    # cs/Intel_SGX_ECDSA_QuoteLibReference_DCAP_API.pdf#%5B%7B%22num%22%3A73%2C%2
    # 2gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C52%2C375%2C0%5D>
    data: bytes = betterproto.bytes_field(1)


@dataclass
class Collateral(betterproto.Message):
    """
    / A representation of/
    [`sgx_ql_qve_collateral_t`](https://download.01.org/intel-sgx/latest/dcap-l
    atest/linux/docs/Intel_SGX_ECDSA_QuoteLibReference_DCAP_API.pdf#%5B%7B%22nu
    m%22%3A70%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C52%2C230%2C0%
    5D)/ All certificate and CRL values are DER encoded./ All fields should be
    present This is type is used in block chain types and should not have
    fields removed. New fields can be added, but will be assumed optional by
    consumers
    """

    # / The Provisioning Certification Key (PCK) certificate revocation list/
    # (CRL) issuer chain. This is a sequence of DER formatted certificates.//
    # This chain is used to verify the `pck_crl`. The consumers should/ have the
    # root CA, which signed this issuer chain.
    pck_crl_issuer_chain: List[bytes] = betterproto.bytes_field(1)
    # / The root certificate authority (CA) certificate revocation list/ (CRL) in
    # DER format.// This will be the "Intel® SGX Root CA CRL" described in/ <http
    # s://api.trustedservices.intel.com/documents/Intel_SGX_PCK_Certificate_CRL_S
    # pec-1.5.pdf>.// It can manually be retrieved from/
    # <https://certificates.trustedservices.intel.com/IntelSGXRootCA.der>
    root_ca_crl: bytes = betterproto.bytes_field(2)
    # / The the Provisioning Certification Key (PCK) certificate revocation/ list
    # (CRL) in DER format.// This will be the "Intel® SGX PCK Processor CA CRL"
    # described in/ <https://api.trustedservices.intel.com/documents/Intel_SGX_PC
    # K_Certificate_CRL_Spec-1.5.pdf>.
    pck_crl: bytes = betterproto.bytes_field(3)
    # / The Trusted Computing Base (TCB) info issuer chain./ This is a sequence
    # of DER formatted certificates.// This is the x509 certificate chain that
    # can verify the signature on/ the `tcb_info`. Consumers should have the root
    # CA which signed this/ issuer chain.
    tcb_info_issuer_chain: List[bytes] = betterproto.bytes_field(4)
    # / The Trusted Computing Base (TCB) info.// JSON formatted TCB info
    # described at/
    # <https://api.portal.trustedservices.intel.com/documentation#pcs-tcb-
    # info-v4>
    tcb_info: str = betterproto.string_field(5)
    # / The Quoting Enclave (QE) identity issuer chain.// This is the x509
    # certificate chain that can verify the signature on/ the `qe_identity`.
    # Consumers should have the root CA which signed/ this issuer chain.
    qe_identity_issuer_chain: List[bytes] = betterproto.bytes_field(6)
    # / The Quoting Enclave (QE) identity.// JSON formatted QE identity info
    # described at/
    # <https://api.portal.trustedservices.intel.com/documentation#pcs-enclave-
    # identity-v4>
    qe_identity: str = betterproto.string_field(7)


@dataclass
class EnclaveReportDataContents(betterproto.Message):
    """
    / Structure for holding the contents of the Enclave's Report Data./ The
    Enclave Quote's ReportData member contains a SHA256 hash of this/
    structure's contents./ The hash is generated via the raw bytes from the
    nonce || key || custom_identity./ If `custom_identity` is not present it is
    omitted from the hash. This is type is used in block chain types and should
    not have fields removed. New fields can be added, but will be assumed
    optional by consumers
    """

    # / The nonce used for generating the quote./ Must be exactly 16 bytes long
    # (see mc-sgx-core-types::QuoteNonce).
    nonce: bytes = betterproto.bytes_field(1)
    # / The public key of the enclave, it's an x25519 key./ Must be exactly 32
    # bytes long.
    key: bytes = betterproto.bytes_field(2)
    # / An optional custom identity of the enclave./ Must be exactly 32 bytes
    # long.
    custom_identity: bytes = betterproto.bytes_field(3)


@dataclass
class DcapEvidence(betterproto.Message):
    """
    / Attestation evidence for DCAP This is type is used in block chain types
    and should not have fields removed. New fields can be added, but will be
    assumed optional by consumers
    """

    # / The quote that was generated by the enclave and signed by the QE(Quoting
    # Enclave).
    quote: "Quote3" = betterproto.message_field(1)
    # / The collateral that was used to generate the quote.
    collateral: "Collateral" = betterproto.message_field(2)
    # / The report data for the quote. The SHA256 hash of the contents of/ this
    # is included in the quote's ReportData member.
    report_data: "EnclaveReportDataContents" = betterproto.message_field(3)


@dataclass
class MintTxPrefix(betterproto.Message):
    """
    / The contents of a mint-tx, which is a transaction to mint new tokens.
    """

    # / Token ID we are minting.
    token_id: int = betterproto.uint64_field(1)
    # / Amount we are minting.
    amount: int = betterproto.uint64_field(2)
    # / The destination's public subaddress view key 'C'.
    view_public_key: "CompressedRistretto" = betterproto.message_field(3)
    # / The destination's public subaddress spend key `D`.
    spend_public_key: "CompressedRistretto" = betterproto.message_field(4)
    # / Nonce, to prevent replay attacks./ Must be exactly 64 bytes long (see
    # constant constants::NONCE_LENGTH).
    nonce: bytes = betterproto.bytes_field(5)
    # / The block index at which this transaction is no longer valid.
    tombstone_block: int = betterproto.uint64_field(6)
    # / The (optional) encrypted fog hint of the minted TxOut.
    e_fog_hint: "EncryptedFogHint" = betterproto.message_field(7)


@dataclass
class MintTx(betterproto.Message):
    """/ A mint transaction coupled with a signature over it."""

    prefix: "MintTxPrefix" = betterproto.message_field(1)
    signature: "Ed25519MultiSig" = betterproto.message_field(2)


@dataclass
class MintConfig(betterproto.Message):
    """
    / A minting configuration for a single token ID./ The minting configuration
    specifies who is allowed to submit mint/ transactions, for which token and
    at what total limit.
    """

    # / Token ID this configuration applies to.
    token_id: int = betterproto.uint64_field(1)
    # / The set of keys that can sign a minting transaction.
    signer_set: "Ed25519SignerSet" = betterproto.message_field(2)
    # / The maximal amount this configuration can mint from the moment it has/
    # been applied.
    mint_limit: int = betterproto.uint64_field(3)


@dataclass
class MintConfigTxPrefix(betterproto.Message):
    """
    / The contents of a mint-config transaction. This transaction alters the/
    minting configuration for a single token ID.
    """

    # / Token ID we are replacing the configuration set for.
    token_id: int = betterproto.uint64_field(1)
    # / The new configuration.
    configs: List["MintConfig"] = betterproto.message_field(2)
    # / Nonce, to prevent replay attacks./ Must be exactly 64 bytes long (see
    # constant constants::NONCE_LENGTH).
    nonce: bytes = betterproto.bytes_field(3)
    # / The block index at which this transaction is no longer valid.
    tombstone_block: int = betterproto.uint64_field(4)
    # / The maximal amount that can be minted by configurations specified in/
    # this tx. This amount is shared amongst all configs.
    total_mint_limit: int = betterproto.uint64_field(5)


@dataclass
class MintConfigTx(betterproto.Message):
    """/ A mint-config transaction coupled with a signature over it."""

    prefix: "MintConfigTxPrefix" = betterproto.message_field(1)
    signature: "Ed25519MultiSig" = betterproto.message_field(2)


@dataclass
class ValidatedMintConfigTx(betterproto.Message):
    """
    / A mint-config transaction coupled with the data used to validate it.
    """

    mint_config_tx: "MintConfigTx" = betterproto.message_field(1)
    signer_set: "Ed25519SignerSet" = betterproto.message_field(2)


@dataclass
class UnmaskedAmount(betterproto.Message):
    """The amount and blinding factor of a TxOut"""

    # The value of the amount commitment
    value: float = betterproto.fixed64_field(1)
    # The token_id of the amount commitment
    token_id: float = betterproto.fixed64_field(2)
    # The blinding factor of the amount commitment
    blinding: "CurveScalar" = betterproto.message_field(3)


@dataclass
class SignedContingentInput(betterproto.Message):
    """
    A pre-signed transaction input with associated rules, as described in MCIP
    #31
    """

    # The block version rules used when making this signature
    block_version: int = betterproto.uint32_field(1)
    # The tx_in which was signed
    tx_in: "TxIn" = betterproto.message_field(2)
    # The Ring MLSAG signature, conferring spending authority
    mlsag: "RingMLSAG" = betterproto.message_field(3)
    # The amount and blinding of the pseudo-output of the MLSAG
    pseudo_output_amount: "UnmaskedAmount" = betterproto.message_field(4)
    # / The amount and blinding of any TxOut required by the input rules
    required_output_amounts: List["UnmaskedAmount"] = betterproto.message_field(5)
    # / The tx_out global index of each ring member/ This helps the recipient of
    # this payload construct proofs of membership for the ring
    tx_out_global_indices: List[float] = betterproto.fixed64_field(6)


@dataclass
class Amount(betterproto.Message):
    """The amount of a Txout"""

    # The value of the amount
    value: float = betterproto.fixed64_field(1)
    # The token_id of the amount
    token_id: float = betterproto.fixed64_field(2)


@dataclass
class OutputSecret(betterproto.Message):
    """
    / The secrets corresponding to an output that we are trying to authorize/
    creation of
    """

    # / The amount of the output we are creating
    amount: "Amount" = betterproto.message_field(1)
    # / The blinding factor of the output we are creating
    blinding: "CurveScalar" = betterproto.message_field(2)


@dataclass
class InputSecret(betterproto.Message):
    """
    / The secrets needed to create a signature that spends an existing output
    as/ an input
    """

    onetime_private_key: "RistrettoPrivate" = betterproto.message_field(
        1, group="onetime_key_derive_data"
    )
    subaddress_index: float = betterproto.fixed64_field(
        2, group="onetime_key_derive_data"
    )
    # / The amount of the output we are spending
    amount: "Amount" = betterproto.message_field(3)
    # / The blinding factor of the output we are spending
    blinding: "CurveScalar" = betterproto.message_field(4)


@dataclass
class ReducedTxOut(betterproto.Message):
    """
    / A reduced representation of the TxOut's in the ring. For each ring/
    member we have only:/ * The onetime-address (tx_out.target_key)/ * The
    compressed commitment (tx_out.amount.commitment)
    """

    # / The tx_out.public_key field
    public_key: "CompressedRistretto" = betterproto.message_field(1)
    # / The tx_out.target_key field
    target_key: "CompressedRistretto" = betterproto.message_field(2)
    # / The tx_out.masked_amount.commitment field
    commitment: "CompressedRistretto" = betterproto.message_field(3)


@dataclass
class SignableInputRing(betterproto.Message):
    """
    / A representation of the part of the input ring needed to create an MLSAG
    """

    # / A reduced representation of the TxOut's in the ring.
    members: List["ReducedTxOut"] = betterproto.message_field(1)
    # / The index of the TxOut in the ring that we are spending
    real_input_index: int = betterproto.uint32_field(2)
    # / The secrets needed to sign that input
    input_secret: "InputSecret" = betterproto.message_field(3)


@dataclass
class PresignedInputRing(betterproto.Message):
    """
    / A presigned RingMLSAG and ancillary data needed to incorporate it into a/
    signature
    """

    # / The mlsag signature authorizing the spending of an input
    mlsag: "RingMLSAG" = betterproto.message_field(1)
    # / The amount and blinding factor of the pseudo output
    pseudo_output_secret: "OutputSecret" = betterproto.message_field(2)


@dataclass
class InputRing(betterproto.Message):
    """
    / An enum which is either a PresignedInputRing or a SignableInputRing
    """

    signable: "SignableInputRing" = betterproto.message_field(1, group="ring")
    presigned: "PresignedInputRing" = betterproto.message_field(2, group="ring")


@dataclass
class UnsignedTx(betterproto.Message):
    """
    / A structure containing an unsigned transaction, together with the data/
    required to sign it that does not involve the spend private key.
    """

    # / The fully constructed TxPrefix.
    tx_prefix: "TxPrefix" = betterproto.message_field(1)
    # / A "ring" of transaction outputs.
    rings: List["InputRing"] = betterproto.message_field(2)
    # / The block version that this transaction is valid for.
    block_version: int = betterproto.uint32_field(4)
    # / The unblinding data for each of the outputs we are creating./ This also
    # contains the output secrets needed for building the signature./ (Those were
    # previously at tag value 3)
    tx_out_unblinding_data: List[
        "TxOutSummaryUnblindingData"
    ] = betterproto.message_field(5)


@dataclass
class TxOutSummaryUnblindingData(betterproto.Message):
    # / An unmasked amount, corresponding to the MaskedAmount field/ The block
    # version appears in the TxSummaryUnblindingData.
    unmasked_amount: "UnmaskedAmount" = betterproto.message_field(1)
    # / The public address to which this TxOut is addressed./ If this output
    # comes from an SCI then we may not know the public/ address.
    address: "PublicAddress" = betterproto.message_field(2)
    # / The tx_private_key generated for this TxOut. This is an entropy source/
    # which introduces randomness into the cryptonote stealth addresses/
    # (tx_public_key and tx_target_key) of the TxOut.// If this output comes from
    # an SCI then we may not know this.
    tx_private_key: "RistrettoPrivate" = betterproto.message_field(3)


@dataclass
class SigningData(betterproto.Message):
    """
    / A structure that contains all the data required to sign a transaction
    that/ does not rely on having the spend private key.
    """

    # / The bytes actually signed by MLSAG signatures./ This is different
    # depending on what block version we are in./ * In the oldest block versions,
    # this is a large number of bytes called the/   "extended message", which
    # includes a tx prefix as well as the pseudo output commitments./ * In block
    # version 2, this is instead 32 bytes called the "extended message digest"./
    # * In block version 3, this is instead 32 bytes called the "extended-
    # message-and-tx-summary digest".// Note that SCI's are the exception to
    # this, they sign the digest based on their TxIn instead,/ see MCIP #31 for
    # more on that. Everything that isn't an SCI signs this.
    mlsag_signing_digest: bytes = betterproto.bytes_field(1)
    # / The actual pseudo output commitments use the blindings from/
    # `pseudo_output_blinding` and not the original true input.
    pseudo_output_blindings: List["CurveScalar"] = betterproto.message_field(2)
    # / Commitments of value equal to each real input.
    pseudo_output_commitments: List["CompressedRistretto"] = betterproto.message_field(
        3
    )
    # / Before mixed transactions feature, there is one range proof for all
    # pseudo-output/ and output commitments, whose serialized bytes appear here./
    # After mixed transactions feature, this field is empty.
    range_proof_bytes: bytes = betterproto.bytes_field(4)
    # / Before mixed transactions feature, this field is empty./ After mixed
    # transactions feature, this field contains one range proof for each/ token
    # id which appears in the transaction, in sorted order of token ids./ It
    # range-proofs the pseudo-outputs and outputs with that token id, in the
    # order/ that they appear in the transaction.
    range_proofs: List[bytes] = betterproto.bytes_field(5)
    # / The token ids of each pseudo ouptut. There must be one of these for each
    # TxIn./ Before mixed transactions feature, this field is empty, and the
    # token ids of/ all pseudo-outputs are inferred from the
    # tx.prefix.fee_token_id.
    pseudo_output_token_ids: List[float] = betterproto.fixed64_field(6)
    # / The token ids of each output. There must be one of these for each output
    # of the Tx./ (tx.prefix.outputs)./ Before mixed transactions feature, this
    # field is empty, and the token ids of/ all outputs are inferred from the
    # tx.prefix.fee_token_id.
    output_token_ids: List[float] = betterproto.fixed64_field(7)
